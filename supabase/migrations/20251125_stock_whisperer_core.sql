BEGIN;

CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

CREATE TABLE IF NOT EXISTS public.symbols (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ticker TEXT NOT NULL UNIQUE,
  name TEXT,
  exchange TEXT
);

CREATE TABLE IF NOT EXISTS public.options_snapshot (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  symbol_id BIGINT NOT NULL REFERENCES public.symbols(id) ON DELETE CASCADE,
  asof TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS options_snapshot_symbol_asof_desc_idx
  ON public.options_snapshot (symbol_id, asof DESC);

CREATE TABLE IF NOT EXISTS public.options_contract (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  snapshot_id BIGINT NOT NULL REFERENCES public.options_snapshot(id) ON DELETE CASCADE,
  exp DATE NOT NULL,
  strike NUMERIC(18,8) NOT NULL,
  type CHAR(1) NOT NULL CHECK (type IN ('C','P')),
  bid NUMERIC(18,8),
  ask NUMERIC(18,8),
  last NUMERIC(18,8),
  volume BIGINT,
  oi BIGINT,
  iv NUMERIC(18,8),
  delta NUMERIC(18,8),
  gamma NUMERIC(18,8),
  theta NUMERIC(18,8),
  vega NUMERIC(18,8),
  rho NUMERIC(18,8),
  UNIQUE (snapshot_id, exp, strike, type)
);

CREATE INDEX IF NOT EXISTS options_contract_exp_strike_idx
  ON public.options_contract (exp, strike);

CREATE INDEX IF NOT EXISTS options_contract_snapshot_idx
  ON public.options_contract (snapshot_id);

CREATE TABLE IF NOT EXISTS public.options_metrics (
  contract_id BIGINT PRIMARY KEY REFERENCES public.options_contract(id) ON DELETE CASCADE,
  mid NUMERIC(18,8),
  spread_bps NUMERIC(18,8),
  liq_score NUMERIC(6,2),
  iv_pctile NUMERIC(6,2),
  exp_move NUMERIC(18,8),
  rr NUMERIC(18,8),
  pop NUMERIC(6,2),
  score NUMERIC(6,2)
);

CREATE INDEX IF NOT EXISTS options_metrics_score_desc_idx
  ON public.options_metrics (score DESC);

CREATE TABLE IF NOT EXISTS public.forecasts (
  symbol_id BIGINT NOT NULL REFERENCES public.symbols(id) ON DELETE CASCADE,
  timeframe TEXT NOT NULL CHECK (timeframe IN ('1h','1d')),
  asof TIMESTAMPTZ NOT NULL,
  horizon_minutes INT NOT NULL,
  yhat NUMERIC(18,8) NOT NULL,
  yhat_lo NUMERIC(18,8),
  yhat_hi NUMERIC(18,8),
  model TEXT NOT NULL,
  version TEXT NOT NULL,
  PRIMARY KEY (symbol_id, timeframe, asof, horizon_minutes)
);

CREATE INDEX IF NOT EXISTS forecasts_symbol_tf_asof_desc_idx
  ON public.forecasts (symbol_id, timeframe, asof DESC);

CREATE TABLE IF NOT EXISTS public.alerts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  target_kind TEXT NOT NULL CHECK (target_kind IN ('symbol','contract','ranking')),
  condition_json JSONB NOT NULL,
  active BOOLEAN NOT NULL DEFAULT TRUE,
  last_fired_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS alerts_user_active_idx
  ON public.alerts (user_id, active);

CREATE TABLE IF NOT EXISTS public.alert_events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  alert_id BIGINT NOT NULL REFERENCES public.alerts(id) ON DELETE CASCADE,
  fired_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  payload_json JSONB NOT NULL
);

ALTER TABLE public.alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.alert_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.forecasts ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'alerts'
      AND policyname = 'Users manage their own alerts'
  ) THEN
    CREATE POLICY "Users manage their own alerts"
      ON public.alerts
      FOR ALL
      USING (auth.uid() = user_id)
      WITH CHECK (auth.uid() = user_id);
  END IF;
END;
$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'alert_events'
      AND policyname = 'Users view their own alert events'
  ) THEN
    CREATE POLICY "Users view their own alert events"
      ON public.alert_events
      FOR SELECT
      USING (alert_id IN (
        SELECT id FROM public.alerts WHERE user_id = auth.uid()
      ));
  END IF;
END;
$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'forecasts'
      AND policyname = 'Read forecasts for authenticated users'
  ) THEN
    CREATE POLICY "Read forecasts for authenticated users"
      ON public.forecasts
      FOR SELECT
      TO authenticated
      USING (true);
  END IF;
END;
$$;

REVOKE ALL ON public.forecasts FROM anon, authenticated;
GRANT SELECT ON public.forecasts TO authenticated;

COMMIT;
